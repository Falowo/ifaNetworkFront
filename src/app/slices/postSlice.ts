import {
  // createAsyncThunk,
  createSlice,
  // PayloadAction,
} from "@reduxjs/toolkit";
import { IPost } from "../../interfaces";
// import { IUser } from "../../interfaces";
// import { AppDispatch, RootState } from "../store";

// import { AxiosResponse } from "axios";

export interface IClassicPagePosts {
  classicPageId: string;
  IPosts: IPost[];
}

export interface IOduPosts {
  oduBinId: number;
  oduId?: string;
  title?: string;
  posts: IPost[];
}

export interface IUserProfilePosts {
  userSub: string;
  userId?: string;
  posts: IPost[];
}

export interface IPostState {
  classicPagesPosts: IClassicPagePosts[];
  ifaPosts: IOduPosts[];
  usersProfilesPost: IUserProfilePosts[];
}

const initialState: IPostState = {
  ifaPosts: [],
  classicPagesPosts: [],
  usersProfilesPost: [],
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

// export const getOrCreateUserDBSecureAsync =
//   createAsyncThunk<
//     IUser | null,
//     IUser,
//     {
//       // dispatch: ThunkDispatch<unknown, unknown, AnyAction>;
//       dispatch: AppDispatch;
//       state: RootState;
//     }
//   >(
//     "auth/getOrCreateUserDBSecureAsync",
//     async (authUser, { dispatch, getState }) => {

//
//         const response = await getOrCreateCurrentUserSecure(
//           token,
//           authUser,
//         );
//         const user: IUser = response.data;

//         return user;
//
//     },
//   );

export const postSlice = createSlice({
  name: "auth",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the Immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes
    // Use the PayloadAction type to declare the contents of `action.payload`
    // toggleDarkMode: (
    //   state,
    //   action?: PayloadAction<boolean>,
    // ) => {
    //   state.darkMode = action
    //     ? action.payload
    //     : !state.darkMode;
    // },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    // builder
    //   .addCase(getOrCreateUserDBAsync.pending, (state) => {
    //     state.isFetching = true;
    //   })
    //   .addCase(
    //     getOrCreateUserDBAsync.fulfilled,
    //     (state, action) => {
    //       const user: IUser | null = action.payload;
    //       state.isFetching = false;
    //       state.userDB = user || undefined;
    //     },
    //   )
    //   .addCase(
    //     getOrCreateUserDBAsync.rejected,
    //     (state, action) => {
    //       state.isFetching = false;
    //       toast(action.error.message, position);
    //     },
    //   );
  },
});

// export const selectAuthUser = (state: RootState) =>
//   state.auth.authUser;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

export default postSlice.reducer;
