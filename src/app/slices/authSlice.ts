import {
  createAsyncThunk,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";
// import { IUser } from "../../interfaces";
import { AppDispatch, RootState } from "../store";
import { User } from "@auth0/auth0-react";
import {
  getPublicRequest,
  getPrivateRequest,
} from "../../api/auth.api";
import { toast } from "react-toastify";
// import { AxiosResponse } from "axios";

const position = {
  position: toast.POSITION.BOTTOM_RIGHT,
};

export interface AuthState {
  authUser?: User;
  token?: string;
  isFetching: boolean;
  error: boolean;
  darkMode: boolean;
}

const initialState: AuthState = {
  authUser: undefined,
  token: undefined,
  isFetching: false,
  error: false,
  darkMode: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const tryTheRequestAndDbAsync = createAsyncThunk<
  any,
  string,
  {
    // dispatch: ThunkDispatch<unknown, unknown, AnyAction>;
    dispatch: AppDispatch;
    state: RootState;
  }
>(
  "auth/tryTheRequestAndDb",
  async (anyString, { dispatch, getState }) => {
    console.log(anyString);

    const token = selectToken(getState());
    console.log(token);

    if (!!token) {
      const privateResponse = await getPrivateRequest(
        token,
      );
      const privateRequestData = privateResponse.data;

      const publicResponse = await getPublicRequest(token);
      const publicRequestData = publicResponse.data;

      return { privateRequestData, publicRequestData };
    } else return null;
  },
);

export const authSlice = createSlice({
  name: "auth",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the Immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes

    // Use the PayloadAction type to declare the contents of `action.payload`
    toggleDarkMode: (
      state,
      action?: PayloadAction<boolean>,
    ) => {
      state.darkMode = action
        ? action.payload
        : !state.darkMode;
    },
    setToken: (
      state,
      action: PayloadAction<string | undefined>,
    ) => {
      state.token = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(tryTheRequestAndDbAsync.pending, (state) => {
        state.isFetching = true;
      })
      .addCase(
        tryTheRequestAndDbAsync.fulfilled,
        (state, action) => {
          const req = action.payload;

          state.isFetching = false;
          console.log({ req });
        },
      )
      .addCase(
        tryTheRequestAndDbAsync.rejected,
        (state, action) => {
          state.isFetching = false;
          toast(action.error.message, position);
        },
      );
  },
});

export const { toggleDarkMode, setToken } =
  authSlice.actions;

export const selectAuthUser = (state: RootState) =>
  state.auth.authUser;
export const selectToken = (state: RootState) =>
  state.auth.token;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

export default authSlice.reducer;
