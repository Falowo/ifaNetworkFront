import {
  createAsyncThunk,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";
// import { IUser } from "../../interfaces";
import { RootState } from "../store";
import { User } from "@auth0/auth0-react";

import { toast } from "react-toastify";
import { getOrCreateCurrentUserSecure } from "../../api/currentUser.api";
import { IUser } from "../../interfaces";
// import { AxiosResponse } from "axios";

const position = {
  position: toast.POSITION.BOTTOM_RIGHT,
};

export interface AuthState {
  authUser?: User;
  userDB?: IUser;
  isFetching: boolean;
  error: boolean;
  theme: "darkTheme" | "lightTheme";
}

const initialState: AuthState = {
  authUser: undefined,
  userDB: undefined,
  isFetching: false,
  error: false,
  theme: "darkTheme",
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export interface IGetOrCreateUserSecure {
  authUser: User;
  accessToken: string;
}

export const getOrCreateUserDBSecureAsync =
  createAsyncThunk<IUser | null, IGetOrCreateUserSecure>(
    "auth/getOrCreateUserDBSecureAsync",
    async (args) => {
      const { authUser, accessToken } = args;
      if (!!accessToken) {
        const response = await getOrCreateCurrentUserSecure(
          accessToken,
          authUser,
        );
        const userDB: IUser = response.data;

        return userDB;
      } else return null;
    },
  );

export const authSlice = createSlice({
  name: "auth",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the Immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes

    // Use the PayloadAction type to declare the contents of `action.payload`
    toggleDarkMode: (
      state,
      action: PayloadAction<"darkTheme" | "lightTheme">,
    ) => {
      state.theme = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(
        getOrCreateUserDBSecureAsync.pending,
        (state) => {
          state.isFetching = true;
        },
      )
      .addCase(
        getOrCreateUserDBSecureAsync.fulfilled,
        (state, action) => {
          const userDB: IUser | null = action.payload;
          state.isFetching = false;
          state.userDB = userDB || undefined;
        },
      )
      .addCase(
        getOrCreateUserDBSecureAsync.rejected,
        (state, action) => {
          state.isFetching = false;
          toast(action.error.message, position);
        },
      );
  },
});

export const { toggleDarkMode } = authSlice.actions;

export const selectAuthUser = (state: RootState) =>
  state.auth.authUser;
export const selectUserDB = (state: RootState) =>
  state.auth.userDB;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

export default authSlice.reducer;
